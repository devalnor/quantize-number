{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap f2eca2cac69880a287f7","webpack:///./src/quantize-number.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACzBA,UAAS,cAAc,CAAC,GAAG,EAAE,OAAO,EAAwB;oEAAJ,EAAE;;yBAAnB,KAAK;OAAL,KAAK,8BAAG,KAAK;;AAClD,OAAI,CAAC,OAAO,EAAE;AAAE,YAAO,CAAC,CAAC;IAAE;AAC3B,OAAI,SAAS,GAAG,GAAG,GAAG,OAAO;;;AAG7B,OAAI,IAAI,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;AAC7B,OAAI,GAAG,GAAG,KAAK,IAAI,SAAS,GAAG,OAAO,GAAG,CAAC,CAAC;AAC3C,UAAO,GAAG,GAAG,SAAS,GAAG,IAAI,GAAG,GAAG,CAAC;EACrC,CAAC;;mBAEa,cAAc,C","file":"quantize-number.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"quantizeNumber\"] = factory();\n\telse\n\t\troot[\"quantizeNumber\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap f2eca2cac69880a287f7\n **/","// Quantize a `val` by `quantum`.\n// The third parameter is `options`. At the moment, there's only a single\n// option, which is `cover`. This is whether the algorithm should be covering\n// or fitting.\n//\n// These examples may help demonstrate the difference between that option:\n//\n// quantizeNumber(7, 5, {cover: false}) === 5\n// quantizeNumber(7, 5, {cover: true}) === 10\n//\n// The algorithm is symmetrical about zero, so you can just make every\n// number in the above example negative to see how it behaves when negative\n// numbers are presented.\nfunction quantizeNumber(val, quantum, {cover = false} = {}) {\n  if (!quantum) { return 0; }\n  var remainder = val % quantum;\n  // I'm intentionally not using Math.sign so that no polyfill is\n  // required to use this library in legacy environments.\n  var sign = val >= 0 ? 1 : -1;\n  var mod = cover && remainder ? quantum : 0;\n  return val - remainder + sign * mod;\n};\n\nexport default quantizeNumber;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/quantize-number.js\n **/"],"sourceRoot":""}